<#
Generated by ChatGPT - Validated by Leonard Haddad, 28/09/2025.

Execution:

```powershell
./monitor-connections.ps1 [optional csv filepath]
```

Continuously monitors external TCP/UDP connections (excluding loopback, listening, wildcard),
displays PID, process name, service/parent info, remote IP/port, state, and DNS hostname.
Highlights new connections.
#>

param(
    [string]$OutCsv,
    [int]$RefreshSeconds = 90
)

$seen = @{}
$loopbacks = @("127.0.0.1","::1")
$wildcards = @("0.0.0.0","::")

function Get-ServiceOrParentName {
    param($proc)
    if ($proc.ProcessName -eq "svchost") {
        try {
            $services = (Get-WmiObject Win32_Service | Where-Object { $_.ProcessId -eq $proc.Id }).Name
            if ($services) { return ($services -join ",") }
        } catch { }
        return $proc.ProcessName
    } elseif ($proc.ProcessName -eq "conhost") {
        try {
            $parent = (Get-CimInstance Win32_Process -Filter "ProcessId=$($proc.Id)").ParentProcessId
            $parentProc = Get-Process -Id $parent -ErrorAction SilentlyContinue
            if ($parentProc) { return "$($proc.ProcessName) (Parent: $($parentProc.ProcessName))" }
        } catch { }
        return $proc.ProcessName
    } else {
        return $proc.ProcessName
    }
}

function Resolve-HostSafely {
    param($ip)
    try {
        [System.Net.Dns]::GetHostEntry($ip).HostName
    } catch { return $null }
}

function Get-CurrentConnections {
    $list = @()

    # TCP connections
    $tcp = Get-NetTCPConnection -ErrorAction SilentlyContinue |
        Where-Object {
            $_.RemoteAddress -and
            ($loopbacks -notcontains $_.RemoteAddress) -and
            ($wildcards -notcontains $_.RemoteAddress) -and
            ($_.RemoteAddress -ne "") -and
            ($_.State -ne "Listen")
        }

    foreach ($c in $tcp) {
        try { $proc = Get-Process -Id $c.OwningProcess -ErrorAction Stop } catch { $proc = $null }
        $list += [PSCustomObject]@{
            Proto      = "TCP"
            PID        = $c.OwningProcess
            Process    = if ($proc) { Get-ServiceOrParentName $proc } else { "Unknown" }
            RemoteIP   = $c.RemoteAddress
            RemotePort = $c.RemotePort
            State      = $c.State
            DNSName    = $null
        }
    }

    # UDP connections (only connected ones)
    $udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue |
        Where-Object { $_.RemoteAddress -and ($loopbacks -notcontains $_.RemoteAddress) -and ($wildcards -notcontains $_.RemoteAddress) }
    foreach ($c in $udp) {
        try { $proc = Get-Process -Id $c.OwningProcess -ErrorAction Stop } catch { $proc = $null }
        $list += [PSCustomObject]@{
            Proto      = "UDP"
            PID        = $c.OwningProcess
            Process    = if ($proc) { Get-ServiceOrParentName $proc } else { "Unknown" }
            RemoteIP   = $c.RemoteAddress
            RemotePort = $c.RemotePort
            State      = "-"
            DNSName    = $null
        }
    }

    return $list
}

# Header
$fmt = "{0,-4} {1,-6} {2,-40} {3,-21} {4,-6} {5,-10} {6}"
Write-Host ($fmt -f 'Proto','PID','Process/Service','Remote','Port','State','DNS')
Write-Host ('-' * 110)

while ($true) {
    $current = Get-CurrentConnections

    Clear-Host
    Write-Host ($fmt -f 'Proto','PID','Process/Service','Remote','Port','State','DNS')
    Write-Host ('-' * 110)

    foreach ($i in $current | Sort-Object Proto, Process, RemoteIP) {
        $key = "$($i.Proto)-$($i.PID)-$($i.RemoteIP)-$($i.RemotePort)"

        try { $dns = [System.Net.Dns]::GetHostEntry($i.RemoteIP).HostName } catch { $dns = "" }
        $line = $fmt -f $i.Proto, $i.PID, $i.Process, $i.RemoteIP, $i.RemotePort, $i.State, $dns

        if (-not $seen.ContainsKey($key)) {
            Write-Host $line -ForegroundColor Yellow
            $seen[$key] = $true
        } else {
            Write-Host $line
        }
    }

    if ($OutCsv) {
        try {
            if (-not (Test-Path $OutCsv)) {
                $current | Export-Csv -Path $OutCsv -NoTypeInformation -Force
            } else {
                $current | Export-Csv -Path $OutCsv -NoTypeInformation -Append
            }
        } catch { Write-Host "Failed to save CSV: $_" -ForegroundColor Red }
    }


    Start-Sleep -Seconds $RefreshSeconds
}


