#!/usr/bin/env python3
import os
from os import system, name
from os.path import exists
from os.path import getsize
import socket
import sys
import hashlib
import time


if len(sys.argv) < 2:
    print("Usage: ptransfer ip_addr_of_sender")
    exit()


# Remote ip address
IPAddr = sys.argv[1]


# Port used for connection
Port = 5050


if len(sys.argv) > 2:
	Port = int(sys.argv[2])


# Filename
fileName = "" 


# Clear the screen
def clear():
    if name == 'nt':
        _ = system('cls')
    else:
        _ = system('clear')


# Hash a given value using SHA256
def hash256(fileName):
    sha256_hash = hashlib.sha256()
    with open(fileName,"rb") as f:
        for byte_block in iter(lambda: f.read(4096),b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()
        

def client_file_exists(s):
    data = s.recv(4096).decode()
    if 'SIZE' in data:
        return (True, int(data.split('SIZE:')[1]))
    return (False, 0)


def get_read_threshold(fileSize):
    if fileSize > 2000000:
        return 2000000
    elif fileSize > 200000:
        return 200000
    elif fileSize > 20000:
        return 20000
    elif fileSize > 2000:
        return 2000
    return 1


# Send file to remote
def send_file(server):
    global IPAddr, Port, fileName
    print("Please enter filename with extension!")
    fileName = input("#> ")
    if not len(fileName) or not os.path.exists(fileName):
        print('Filename empty or file doesnt exist in provided path!')
        send_file()
        exit()
    server.bind((IPAddr, Port))
    server.listen(1)
    s, addr = server.accept()
    s.send(bytes(fileName, 'utf-8'))
    s.recv(4096)
    f = open(fileName,'rb')
    s.send(bytes(str(getsize(fileName)),'utf-8'))
    exists, current_size = client_file_exists(s)
    if exists:
        print(f'File exists! Reading {current_size} bytes...')
        i = 0
        while i < current_size:
            threshold = get_read_threshold(current_size - i)
            f.read(threshold)
            i += threshold
    s.send(b'Ready for transfer!')
    s.recv(4096).decode()
    while True:
        try:
            data = f.read(2000000)
            if not len(data):
                break
            s.send(data)
        except Exception as e:
            break
    s.send(b"[DONE]")
    s.recv(4096).decode()
    original_hash = hash256(fileName)
    s.send(bytes(original_hash, 'utf-8'))
    f.close()
    print("File transfer complete.")
    server.close()


def get_readable_file_size(fileSize):
    if fileSize > 1000000000:
        return "%s.%s GB" % (str(int(fileSize / 1000000000)), str(int(fileSize / 10000000))[-2:-1])
    elif fileSize > 1000000:
        return "%s.%s MB" % (str(int(fileSize / 1000000)), str(int(fileSize / 10000))[-2:-1])
    elif fileSize > 1000:
        return "%s.%s KB" % (str(int(fileSize / 1000)), str(int(fileSize / 100))[-1])
    return str(fileSize)


def print_file_size(received_size, previous_file_size, fileSize):
    if previous_file_size != fileSize:
        print(f"Received {received_size} / {fileSize}")


def check_hashes_match(client_socket, fileName):
    print("Checking Hashes:")
    client_socket.send(b"GIVE_ME_HASH")
    original_hash = client_socket.recv(4096).decode()
    received_file_hash = hash256(fileName)
    print("\t[Original Hash]: %s\n\t[Received File Hash]: %s" % (original_hash, received_file_hash))
    if original_hash == received_file_hash:
        print("Hashes match!")
    else:
        print("Hash mismatch, delete file?")
        user_input = input("Y/N #> ")
        if 'y' in user_input.lower():
            os.remove(fileName)
            print("Deleted File!")


def initial_client_comm(client_socket):
    fileName = client_socket.recv(4096).decode()
    client_socket.send(b"Received Name")
    original_size = int(client_socket.recv(4096).decode())
    print("Receiving file...")
    return (fileName, original_size)


def check_file_exists(client_socket, fileName, file_exists):
    if file_exists:
        current_size = getsize(fileName)
        old_filename = fileName + 'old'
        os.rename(fileName, old_filename)
        i = 0
        old_fis = open(old_filename, 'rb')
        with open(fileName, 'wb+') as f:
            while i < current_size:
                threshold = get_read_threshold(current_size - i)
                f.write(old_fis.read(threshold))
                i += threshold
        os.remove(old_filename)
        client_socket.send(bytes(f'SIZE:{current_size}', 'utf-8'))
        return current_size
    else:
        client_socket.send(b'NONEXISTANT')
        return 0


def receive_file():
    global IPAddr, Port, fileName
    client_socket = socket.socket()
    try:
        client_socket.connect((IPAddr,Port))
        fileName, original_size = initial_client_comm(client_socket)
        fileSize = get_readable_file_size(original_size)
        previous_file_size = ""
        start_time = time.time()
        file_exists = os.path.exists(fileName)
        i = check_file_exists(client_socket, fileName, file_exists)
        print(client_socket.recv(4096).decode())
        client_socket.send(b'Beginning file transfer...')
        f = None
        if exists:
            f = open(fileName, 'ab')
        else:
            f = open(fileName, 'wb+')
        done = False
        while not done:
            data = client_socket.recv(2000000)
            i = i + len(data)
            if i > original_size:
                data = data[:-6]
                done = True
            f.write(data)
            clear()
            received_size = get_readable_file_size(i)
            print_file_size(received_size, previous_file_size, fileSize)
            previous_file_size = received_size
        f.close()
        end_time = time.time()
        check_hashes_match(client_socket, fileName)
        print(f'Transfer done in {round(end_time - start_time, 1)} seconds.')
    finally:
        client_socket.close()
    exit()


# Setup
def setup():
    print("Please select type send/receive")
    selected = input("#> ")
    if "s" in selected:
        server = socket.socket()
        try:
            send_file(server)
        except:
            server.close()
    elif "r" in selected:
        receive_file()
    else:
        setup()


setup()
